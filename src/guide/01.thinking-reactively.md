---
title: Thinking reactively
type: guide
order: 101
---

本章节覆盖
* 比较异步 JavaScript 的回调(callbacks)和基于 Promise(Promise-based)的解决方案
* 使用流式(streams)，来对静态数据、动态数据，和时间限制(time-bound)的数据进行建模
* 使用可观察流式(observable streams)，以一种函数式的方式，来处理无时间限制(unbounded)的数据
* 考虑如何响应式地处理异步数据流组合

现在，在世界上某个地方，有人刚刚创建了一个的推文、股票价格刚刚下降、以及一个鼠标刚刚移动。这琐碎的数据点亮了互联网，并通过遍及全球的半导体传播到随处可见的地方。大量的数据在所有互相连接的设备间传递。这与你有什么关系？当你将代码推送到生产环境中时，此时将会在你的 JavaScript 应用程序中的管道上触发事件，这些事件需要预先做好准备，以及进行有效地处理。这产生了两个关键的挑战：可扩展性(scalability)和延迟(latency)。

随着接收到越来越多的数据，应用程序消耗或需要的内存量，将呈线性增长，或者，在最坏的情况下，将呈指数增长。这是可扩展性(scalability)的经典问题，并且尝试一次处理它，必定会导致用户界面（UI - user interface）变得无响应。按钮可能不再似乎起作用，梦幻般动画将变得拖沓，浏览器甚至可能会将页面标记为终止，这对于现代 web 用户来说是不可接受的。

这个问题虽然原本就有，然而，近年来，随着 JavaScript 应用程序需要处理的事件和数据的数量规模呈指数级增长，这就成为了新的问题。数据量太大，不能轻易地取出和存储在内存中以供使用。作为替代方案，我们必须建议从远程位置异步获取数据的方式，从而导致互联软件系统面临的另一个巨大挑战：延迟(latency)，会导致很难表达为代码。

虽然现代系统架构已经极大改善，包括更快的网络设备和高并发处理，然而，随着远程数据的复杂性增加，用于处理数据的库(library)和方式却并没有获得相应的发展。例如，当涉及从服务器获取数据或运行延迟计算时，我们大多数人仍然依赖回调(callbacks)的使用，当业务规则演变和变化时，又或者我们要解决的问题所涉及的数据不在一处，而是在几处不同的远程位置时，回调(callbacks)方式很快就将应用程序代码变得一团混乱。

解决方案不只是在于使用哪个库(library)，而是应该考虑此类问题的最佳配套范式。在本书中，你将首先了解两种新兴范式的基本原理：函数式编程（FP - functional programming）和响应式编程（RP - reactive programming）。令人兴奋的是，将两种范式组合在一起后的函数式响应编程（FRP - functional reactive programming），以及最终体现这种编程思维的代码，被称为 RxJS（或称为 rx.js）的库，这是有效处理异步(asynchronous)和基于事件的数据源(event-based data sources)的最佳配方。

我们规划的路线图包括多个部分。首先，我们会引导你去理解响应式的原则、当前的解决方案、这些方案的缺点，以及 RxJS 是如何改进的。怀着发现新事物的心态，你会深入了解 RxJS 的具体细节，并了解核心操作符(operators)，可以让你以一种简洁优雅的方式，来表现那些复杂的、有时间限制(bounded)数据或无时间限制(unbounded)数据的数据流。你将了解到，为什么 RxJS 是适用于任何体量的、基于事件驱动的应用程序的理想选择。在学习旅途中，你会逐渐找出真实世界中相应例子，印证如何使用这个库(library)，来将多个远程数据、自动完成输入字段、拖放、处理用户输入、创建响应式 UI、并行处理等等组合在一起。这些示例旨在帮助你在学习 RxJS 的最重要功能时缩小范围。最后，我们会所有这些新技术将汇集在一起​​，构建一个使用 React/Rx 混合架构的完整规模的 web 应用程序，来结束你的旅程。

本章的目标是对本书将要学习的主题进行广泛的了解。我们将重点关注当前解决方案的局限性，并指出有关 RxJS 如何解决这些问题。此外，你会学习如何将思维方式转变为流(streams)（也称为事件的函数式序列），在 RxJS 的内部，流(streams)是通过我们熟悉的模式（例如，迭代器模式和观察者模式）实现的。最后，我们将探讨 RxJS 编写异步代码的优势，减少使用回调(callbacks)引起的逻辑纠缠，这也可以扩展到任何量级的数据。了解这两个世界之间的差异至关重要，所以让我们开始吧。

## 同步计算 vs 异步计算

简单来说，将运行时中的同步代码与异步代码，进行分离的主要因素是延迟时间(latency)，也称为等待时间(wait time)。将时序以显式的编码形式表现出来，会使人感到难以理解。当自己书写的代码的顺序，和运行时的代码执行顺序完全同步，你就会很容易根据这些顺序，编写出合适的、易于理解的代码：“执行这段程序，然后立即执行另一段程序”。

但是，如今的计算世界还没有提供如此奢侈的处理能力。在这个高度互联的计算世界中，在发送消息和接受响应的同一时刻，也代表着应用程序能够在此时间范围内，同时去处理一些其他事情，例如，响应用户输入、处理数字、或者更新 UI。这更像是“做这个（等待一段不确定的时间）；然后做另一个”。让应用程序闲置，然后等待数据库返回查询结果、等待网络的响应、或者是等待用户完成操作，这些传统方式是不可接受的，因此需要你利用异步执行，以使应用程序始终处于积极响应的状态。这里的主要问题是，在长时间运行的过程中，阻塞用户操作是否是可接受的。

### Issues with blocking code

Synchronous execution occurs when each block of code must wait for the previous block to complete before running. Without a doubt, this is by far the easiest way to implement code because you put the burden on your users to wait for their processes to complete. Many systems still work this way today, such as ATMs, point of sale systems, and other dumb terminals. Writing code this way is much easier to grasp, maintain, and debug; unfortunately, because of JavaScript’s single-threaded nature, any long-running tasks such as waiting for an AJAX call to return or a database operation to complete shouldn’t be done synchronously. Doing so creates an awful experience for your users because it causes the entire application to sit idle waiting for the data to be loaded and wasting precious computing cycles that could easily be executing other code. This will block further progress on any other tasks that you might want to execute, which in turn leads to artificially long load times, as shown in figure 1.1.

In this case, the program makes a blocking call to process 1, which means it must wait for it to return control to the caller, so that it can proceed with process 2. This might work well for kiosks and dumb terminals, but browser UIs should never be implemented this way. Not only would it create a terrible user experience (UX), but also browsers may deem your scripts unresponsive after a certain period of inactivity and terminate them. Here’s an example of making an HTTP call that will cause your application to block, waiting on the server to respond:

```
let items = blockingHttpCall('/data');
items.forEach(item => {
  // process each item
});
```

Figure 1.1 A program that invokes two processes synchronously. A process in this case can be as simple as a function call, an I/O process, or a network transaction. When process 1 runs, it blocks anything else from running.

A better approach would be to invoke the HTTP call and perform other actions while you’re waiting on the response. Long-running tasks aren’t the only problem; as we said earlier, mouse movement generates a rapid succession of very quick, fine-grained events. Waiting to process each of these synchronously will cause the entire application to become unresponsive, whether it’s long wait times or handling hundreds of smaller waits quickly. So what can you do to handle these types of events in a non-blocking manner? Luckily, JavaScript provides callback functions.

Loading server-side data synchronously halts program execution. The nature of the data isn’t important right now; it’s some generic sample data pertaining to your application.

### Non-blocking code with callback functions

Using functions as callbacks has been a staple of JavaScript development for years. They’re used in everything from mouse clicks and key presses to handling remote HTTP requests or file I/O. JavaScript, being a single-threaded language, requires such a construct in order to maintain any level of usability. Callback functions were created to tackle the problem of blocking for long-running operations to complete by allowing you to provide a handler function that the JavaScript runtime will invoke once the data is ready for use. In the meantime, your application can continue carrying out any other task, as shown in figure 1.2.

Figure 1.2 Callback functions in JavaScript create an inversion of control where functions call the application back, instead of the other way around.

Unlike the previous code that makes a blocking HTTP call that you must wait for, using callbacks with asynchronous (AJAX) requests creates an inversion of control that permits your application to continue executing the next lines of code. Inversion of control in this sense refers to the way in which certain parts of your code receive the flow of control back from the runtime system. In this case, the runtime calls you (or returns control to you) via the function handler when the data is ready to be processed; hence, the term callback. Look at this alternative:

```
ajax('/data', // No explicit return value
  items => { // Declaration of callback function
    items.forEach(item => {
    // process each item
    // All processing is carried out within the callback body after the data has been fetched from the server.
  });
});
beginUiRendering(); // This function begins immediately after AJAX is called.
```

Callback functions allow you to invoke code asynchronously, so that the application can return control to you later. This allows the program to continue with any other task in the meantime. In this code sample, the HTTP function runs in the background and immediately returns control to the caller to begin rendering the UI; it handles the contents of the items only after it has completely loaded. This behavior is ideal because it frees up the application to make progress on other tasks such as loading the rest of a web page, as in this case. As you’ll see throughout this book, asynchronous code is a good design for I/O-bound work like fetching data from the web or a database. The reason this works is that I/O processes are typically much slower than any other type of instruction, so we allow them to run in the background because they’re not dependent on processor cycles to complete.

> In the code sample in section 1.1.2, the second parameter of ajax() is the callback function. In that code, as in many parts of the book, we use the ECMAScript 6 lambda expression syntax, 1 which offers a terser and more succinct way of invoking functions. Also called arrow functions, lambda expressions behave somewhat similarly to an anonymous function call, which you’re probably familiar with. The subtle difference has to do with what the keyword this refers to. On rare occasions, when the value of this is important, we’ll call it out in the text and switch to using an anonymous function expression.

### Understanding time and space

Certainly, asynchronous functions allow us to stay responsive, but they come at a price. Where synchronous programs allow us to reason directly about the state of the application, asynchronous code forces us to reason about its future state. What does this mean? State can be understood simply as a snapshot of all the information stored into variables at any point in time. This information is created and manipulated via sequences of statements. Synchronous code can be thought of as an ordered, step-by-step execution of statements, as shown in figure 1.3.

Figure 1.3 Synchronous code is a step-by-step sequential execution of statements where each step depends on the previous one to run.

In this model, it’s easy to determine at any point what the states of the variables are and what will occur next, which is why it’s easy to write and debug. But when tasks have different wait times or complete at different times, it’s difficult to guarantee how they’ll behave together. Functions that terminate at unpredictable times are typically harder to deal with without the proper methods and practices. When this happens, the mental model of our application needs to shift to compensate for this additional dimension. Compare figure 1.3 to the model in figure 1.4, which grows not only vertically but also horizontally.

Figure 1.4 In asynchronous execution, steps that are invoked in sequence need not terminate all at the same time. So there’s absolutely no guarantee that you can rely on the data from step 1 to be available in step 2, for example.

As of now, if steps 1, 2, and 3 were independent tasks, then executing them in any order wouldn’t be a problem. But if these were functions that shared any global state, then their behavior would be determined by the order in which they were called or by the global state of the system. These conditions we refer to as side effects, which you’ll learn more about in chapter 2; they involve situations where you need to read or modify an external resource like a database, the DOM, the console, and others. Functions with side effects can perform unreliably when run in any arbitrary order. In functional and reactive programming, you’ll learn to minimize them by using pure functions, and you’ll learn in this book that this is extremely advantageous when dealing with asynchronous code.

So, assuming that our functions were side effect free, we still have another important issue—time. Steps 1, 2, and 3 might complete instantly or might not complete depending on the nature of the work. The main issue is how we can guarantee that these steps run in the correct order. As you’ve probably done many times before, the proper way to achieve this is by composing these functions together, so that the output of one becomes the input to the next, and therefore a chain of steps is created. The traditional approach that ensures the proper sequence of steps takes place is to nest a sequence of callbacks, and the model of the application’s runtime resembles figure 1.5.

Figure 1.5 In order to guarantee the proper order of steps and asynchronous invocation takes place, we use callback functions to transfer control of the application once a long-running operation terminates.

Undoubtedly, this nested control flow is much harder to reason about than the synchronous, straight-line model of figure 1.4. In figure 1.5, step 1 runs first, which then calls step 2 as soon as it completes; then step 3 executes, and so on for the rest of the steps. This suggests the presence of a temporal dependency or time coupling between these steps, which means that one can begin as soon as the previous finishes—it’s a chain of commands. In this scenario, the callback functions are used to respond to the asynchronous request that happened before them and begin processing its data. This happens typically when making sequential AJAX requests, but it can also happen when mixing in any other event-based system, whether it be key presses, mouse movements, database reads and writes, and others; all these systems rely on callbacks.

### Are callbacks out of the picture?

The short answer is no. Using a paradigm to tackle event-based or asynchronous code isn’t necessary when you’re dealing with simple interactions with users or external services. If you’re writing a simple script that issues a single remote HTTP request, RxJS is a bit of overkill, and callbacks remain the perfect solution. On the other hand, a library that mixes functional and reactive paradigms really begins to shine when implementing state machines of moderate-to-advanced complexity such as dynamic UIs or service orchestration. Some examples of this can be the need to orchestrate the execution of several business processes that consume several microservices, data mashups, or perhaps the implementation of features of a rich UI made up of several widgets on the page that interact with each other.

Consider the task of loading data from the client originating from different remote server-side endpoints. To coordinate among them, you’d need several nested AJAX requests where each step wraps the processing of the data residing within each callback body in the logic of invoking the next step, as you saw previously in figure 1.5. Following is a possible solution for this, which requires the use of three composed callback functions to load datasets that potentially live in the same host or different hosts, together with its related meta-information and files:

```
ajax(
  '<host1>/items', // Loads all items you want to display
  items => {
    for (let item of items) {
      ajax(
        `<host2>/items/${item.getId()}/info`, // For each item, loads additional meta-information
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles); // For each meta record, loads associated files
        }
      );
    }
  }
);
beginUiRendering();
```

Now although you might think this code looks trivial, if continuing this pattern, we’ll begin to sink into horizontally nested calls—our model starts to grow horizontally. This trend is informally known in the JavaScript world as callback hell, a design that you’ll want to avoid at all costs if you want to create maintainable and easy-to-reason-about programs. It isn’t simply aesthetics—making sure that separate asynchronous operations are synchronized is hard enough without also having difficult-to-read code. There’s another hidden problem with this code. Can you guess what it is? It occurs when you mix a synchronous artifact like a for..of imperative block invoking asynchronous functions. Loops aren’t aware that there’s latency in those calls, so they’ll always march ahead no matter what, which can cause some really unpredictable and hard-to-diagnose bugs. In these situations, you can improve matters by creating closures around your asynchronous functions, managed by using forEach() instead of the loop:

```
ajax(
  '<host1>/items',
  items => {
    items.forEach(item => { // The forEach() method of arrays will properly scope each item object into the nested HTTP call.
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    });
  }
);
```

This is why in RxJS—and FP in general, for that matter—all loops are virtually eliminated! Instead, in chapters 4 and 5 you’ll learn about operators that allow you to spawn sequences of asynchronous requests taking advantage of pure functions to keep all of the information properly scoped. Another good use of callbacks is to implement APIs based on Node.js event emitters. Let’s jump into this next.

### Event emitters

Event emitters are popular mechanisms for asynchronous event-based architectures. The DOM, for instance, is probably one of the most widely known event emitters. On a server like Node.js, certain kinds of objects periodically produce events that cause functions to be called. In Node.js, the EventEmitter class is used to implement APIs for things like WebSocket I/O or file reading/writing so that if you’re iterating through directories and you find a file of interest, an object can emit an event referencing this file for you to execute any additional code.

Let’s implement a simple object to show this API a bit. Consider a simple calculator object that can emit events like add and subtract, which you can hook any custom logic into; see figure 1.6.

Figure 1.6 Node emitter object representing a simple calculator, which exposes two events: add and subtract

Here’s some code for the calculator add and subtract events:

```
const EventEmitter = require('events'); // Loads the events module

class Calculator extends EventEmitter {} // Creates a custom emitter

const calc = new Calculator();

// Handles the add event
calc.addListener('add', (a, b) => {
  calc.emit('result’, a + b);
});

calc.addListener('subtract', (a, b) => {
  calc.emit('result', a - b);
});

calc.addListener('result', (result) => {
  console.log('Result: ' + result);
});

calc.emit('add', 2, 3); //-> Prints 'Result: 5'
calc.emit('subtract', 2, 3); //-> Prints 'Result: 1'
```

Subscribing to an event emitter is done through the addListener() method, which allows you to provide the callback that will be called when an event of interest is fired. Unfortunately, event emitters have all of the same problems associated with using callbacks to handle emitted data coming from multiple composed resources. Overall, composing nested asynchronous flow is difficult.

The JavaScript community as a whole has made strides in the right direction to solve these types of issues. With the help of patterns emerging from FP, an alternative available to you with ES6 is to use Promises.

## Better callbacks with Promises

All hope is not lost; we promise you that. Promises are not part of the RxJS solution, but they work together perfectly well. JavaScript ES6 introduced Promises to represent any asynchronous computation that’s expected to complete in the future. With Promises, you can chain together a set of actions with future values to form a continuation. 2 A continuation is just a fancy term for writing callbacks and has a lot to do with the principle of Inversion of Control we referenced earlier. A continuation (a callback) allows the function to decide what it should do next, instead of indiscriminately waiting for a return value. They’re used heavily when iterating over arrays, tree structures, try/catch blocks, and, of course, asynchronous programming. So, the code you saw earlier—

```
ajax(
  '<host1>/items',
  items => {
    for (let item of items) {
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    }
  }
);
```

—is known to be continuation-passing style (CPS), because none of the functions are explicitly waiting for a return value. But as we mentioned, abusing this makes code hard to reason about. What you can do is to make continuations first-class citizens and actually define a concrete interpretation of what it means to “continue.” So, we introduce the notion of then: “Do X, then do Y,” to create code that reads like this:

```
Fetch all items, then // The key term “then” suggests time and sequence.
  For-each item fetch all files, then
    Process each file
```

This is where Promises come in. A Promise is a data type that wraps an asynchronous or long-running operation, a future value, with the ability for you to subscribe to its result or its error. A Promise is considered to be fulfilled when its underlying operation completes, at which point subscribers will receive the computed result. Because we can’t alter the value of a Promise once it’s been executed, it’s actually an immutable type, which is a functional quality we seek in our programs. Different Promise implementations exist based on the Promises/A+ protocol (see https:// promisesaplus.com/), and it’s designed to provide some level of error handling and continuations via the then() methods. Here’s how you can tackle the same example if you assume that ajax() returns Promises:

```
ajax('<host1>/items')
  .then(items =>
    items.forEach(item =>
      ajax(`<host2>/data/${item.getId()}/info`)
        .then(dataInfo =>
          ajax(`<host3>/data/files/${dataInfo.files}`)
        )
        .then(processFiles);
    )
  );
```

This looks similar to the previous statement! Being a more recent addition to the language with ES6 and inspired in FP design, Promises are more versatile and idiomatic than callbacks. Applying these functions declaratively—meaning your code expresses the what and not the how of what you’re trying to accomplish—into then blocks allows you to express side effects in a pure manner. We can refactor this to be more declarative by pulling out each function independently

```
let getItems = () => ajax('<host1>/items'); let getInfo = item => ajax(`<host2>/data/${item.getId()}/info`); let getFiles = dataInfo => ajax(`<host3>/data/files/${dataInfo.files}`);
```

and then use Promises to stitch together our asynchronous flow. We use the Promise .all() function to map an array of separate Promises into a single one containing an array of results:

```
getItems()
  .then(items => items.map(getInfo))
  .then(promises => Promise.all(promises))
  .then(infos => infos.map(getFiles))
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

The use of then() explicitly implies that there’s time involved among these calls, which is a really good thing. If any step fails, we can also have matching catch() blocks to handle errors and potentially continue the chain of command if necessary, as shown in figure 1.7.

Figure 1.7 Promises create a flow of calls chained by then methods. If the Promise is fulfilled, the chain of functions continues; otherwise, the error is delegated to the Promise catch block.

Of course, Promises also have shortcomings, or else we wouldn’t be talking about Rx. The drawback of using Promises is that they’re unable to handle data sources that produce more than one value, like mouse movements or sequences of bytes in a file stream. Also, they lack the ability to retry from failure—all present in RxJS. The most important downside, moreover, is that because Promises are immutable, they can’t be cancelled. So, for instance, if you use a Promise to wrap the value of a remote HTTP call, there’s no hook or mechanism for you to cancel that work. This is unfortunate because HTTP calls, based on the XmlHttpRequest object, can be aborted, 3 but this feature isn’t honored through the Promise interface. These limitations reduce their usefulness and force developers to write some of the cancellation logic themselves or seek other libraries.

Collectively, Promises and event emitters solve what are essentially the same problems in slightly different ways. They have different use cases (Promises for single-value returns like HTTP requests and event emitters for multiple-value returns like mouse click handlers), mostly because of their own implementation constraints, not because the use cases are so different. The result is that in many scenarios a developer must use both in order to accomplish their goal, which can often lead to disjointed and confusing code.

The problems of readability; hard-to-reason-about code; and the downsides of current technology that we’ve discussed so far aren’t the only reasons that we, as developers, need to worry about asynchronous code. In this next section, we’ll outline more concretely why we need to switch to a different paradigm altogether to tackle these issues head on.

For many years now, we’ve learned to use many JavaScript async libraries; everyone has their own preference, whether it be JQuery, Async.js, Q.js, or others, yet they all fall short one way or another. We believe that it’s not a matter of just choosing a library, but choosing the right paradigm for the job. By combining functional and reactive programming paradigms, RxJS will help you address the following issues:

* Familiar control flow structures (like for and while loops) with asynchronous functions don’t work well together because they’re not async aware; that is, they’re oblivious of wait time or latency between iterations.
* Error-handling strategies become easily convoluted when you begin nesting try/catch blocks within each callback. In chapter 7, we’ll approach error handling from a functional perspective. Also, if you want to implement some level of retry logic at every step, this will be incredibly difficult even with the help of other libraries.
* Business logic is tightly coupled within the nested callback structure you need to support. It’s plain to see that the more nested your code is, the harder it is to reason about. Functions that are deeply nested become entangled with other variables and functions, which is problematic in terms of readability and complexity. It would be ideal to be able to create reusable and modular components in order to have loosely coupled business logic that can be maintained and unit tested independently. We’ll cover unit testing with RxJS in chapter 9.
* You want to avoid excessive use of closures, but functions in JavaScript create a closure around the scope in which they’re declared. Nesting them means that you need to be concerned about not just the state of the variables passed in as arguments but also the state of all external variables surrounding each function declaration, causing side effects to occur. In the next chapter, you’ll learn how detrimental side effects can be and how FP addresses this problem. Side effects increase the cognitive load of the state of your application, making it virtually impossible to keep track of what’s going on in your programs. Throw a few loops and conditional if-else statements into the mix, and you’ll regret the day a bug occurs that impacts this functionality.
* It’s difficult to detect when events or long-running operations go rogue and need to be cancelled. Consider the case of a remote HTTP request that’s taking too long to process. Is the script unresponsive or is the server just slow? It would be ideal to have an easy mechanism to cancel events cleanly after some predetermined amount of time. Implementing your own cancellation mechanism can be very challenging and error prone even with the help of third-party libraries.
* One good quality of responsive design is to always throttle a user’s interaction with any UI components, so that the system isn’t unnecessarily overloaded. In chapter 4, you’ll learn how to use throttling and debouncing to your advantage. Manual solutions for achieving this are typically very hard to get right and involve functions that access data outside their local scope, which breaks the stability of your entire program.
* It’s rare to be concerned about memory management in JavaScript applications, especially client-side code. After all, the browser takes care of most of these low-level details. But as UIs become larger and richer, we can begin to see that lingering event listeners may cause memory leaks and cause the size of the browser process to grow. It’s true that this was more prevalent in older browsers; nevertheless, the complexity of today’s JavaScript applications is no match for the applications of years past.

This long list of problems can certainly overwhelm even the brightest developers. The truth of the matter is that the very paradigms that help us tackle these problems are hard to express in code, which is why a tool like RxJS is necessary to redefine our approach.

You learned that Promises certainly move the needle in the right direction (and RxJS integrates with Promises seamlessly if you feel the need to do so). But what you really need is a solution that abstracts out the notion of latency away from your code while allowing you to model your solutions using a linear sequence of steps through which data can flow over time, as shown in figure 1.8.

In essence, you need to combine the ability to decouple functionality like event emitters with the fluent design pattern of Promises, all into a single abstraction. Moreover, you need to work with both synchronous and asynchronous code, handle errors, discourage side effects, and scale out from one to a deluge of events. This is certainly a long laundry list of things to take care of.

As you think about this, ask yourself these questions: How can you write code as a linear sequence of steps that acts only after some event has occurred in the future? How do you combine it with other code that might have its own set of constraints? Your desire for synchronicity isn’t just about convenience; it’s what you’re used to. Unfortunately, most of the common language constructs that you use in synchronous code aren’t well suited for asynchronous execution. This lack of language support for things like async try/catch, async loops, and async conditionals means that developers must often roll their own. It’s not surprising that in the past few years, other people have asked the same questions and come together with the community at large to address these challenges, emerging as what’s known as the Reactive Extensions—we have arrived!

Figure 1.8 RxJS can treat asynchronous data flows with a programming model that resembles a simple chain of sequential steps.

## The Reactive Extensions for JavaScript

Reactive Extensions for JavaScript (RxJS) is an elegant replacement for callback or Promise-based libraries, using a single programming model that treats any ubiquitous source of events—whether it be reading a file, making an HTTP call, clicking a button, or moving the mouse—in the exact same manner. For example, instead of handling each mouse event independently with a callback, with RxJS you handle all of them combined.

As you’ll learn in chapter 9, RxJS is also inherently robust and easy to test with a vibrant community to support it. The power of RxJS derives from being built on top of the pillars of functional and reactive programming, as well as a few popular design patterns such as observer and iterator that have been used successfully for years. Certainly, RxJS didn’t invent these patterns, but it found ways to use them within the context of FP. We’ll discuss FP and its role in RxJS further in the next chapter; in order to take full advantage of this framework, the key takeaway from this section is that you must learn to think in terms of streams.

### Thinking in streams: data flows and propagation

Whether you deal with thousands of key presses, movement events, touch gestures, remote HTTP calls, or single integers, RxJS treats all of these data sources in exactly the same way, which we’ll refer to as data streams from now on.

> Traditionally, the term stream was used in programming languages as an abstract object related to I/O operations such as reading a file, reading a socket, or requesting data from an HTTP server. For instance, Node.js implements readable, writable, and duplex streams for doing just this. In the RP world, we expand the definition of a stream to mean any data source that can be consumed.

Reactive programming entails a mental shift in the way you reason about your program’s behavior, especially if you come from an imperative background. We’ll illustrate this shift in mindset with a simple exercise:

```
let a = 20;
let b = 22;
let c = a + b; //-> 42

a = 100;
c = ?
```

You can easily predict the value of c in this case: 42. The fact that we changed a didn’t have any influence on the value of c. In other words, there’s no propagation of change. This is the most important concept to understand in reactive programming. Now we’ll show you a pseudo JavaScript implementation of this:

```
A$ = [20]; B$ = [22]; // Creates a stream initialized with the value 22

C$ = A$.concat(B$).reduce(adder); //-> [42] // Concatenates both streams and applies an adder function to get a new container with 42

A$.push(100); // Pushes a new value into A$
C$ = ?
```

First, we’ll explain some of the notation we use here. Streams are containers or wrappers of data very similar to arrays, so we used the array literal notation [] to symbolize this. Also, it’s common to use the $ suffix to qualify variables that point to streams. In the RxJS community, this is known as Finnish Notation, attributed to Andre Staltz, who is one of the main contributors of RxJS and Finnish.

We created two streams, A$ and B$, with one numerical value inside each. Because they’re not primitive objects in JavaScript or have a plus (+) overloaded operator, we need to symbolize addition by concatenating both streams and applying an operator method like reduce with an adder function (this should be somewhat familiar to you if you’ve worked with these array methods). This is represented by C$.

JavaScript ES5 introduced new array methods, known as the array extras, which enable some level of native support for FP. These include map, reduce, filter, some, every, and others.

> ARRAY EXTRAS - What happens to C$ if the value 100 is pushed onto A$? In an imperative program, nothing will actually happen except that A$ will have an extra value. But in the world of streams, where there’s change propagation, if A$ receives a new value (a new event), this state is pushed through any streams that it’s a part of. In this case, C$ gets the value 122. Confused yet? Reactive programming is oriented around data flows and propagation. In this case, you can think of C$ as an always-on variable that reacts to any change and causes actions to ripple through it when any constituent part changes. Now let’s see how RxJS implements this concept.

What happens to C$ if the value 100 is pushed onto A$? In an imperative program, nothing will actually happen except that A$ will have an extra value. But in the world of streams, where there’s change propagation, if A$ receives a new value (a new event), this state is pushed through any streams that it’s a part of. In this case, C$ gets the value 122. Confused yet? Reactive programming is oriented around data flows and propagation. In this case, you can think of C$ as an always-on variable that reacts to any change and causes actions to ripple through it when any constituent part changes. Now let’s see how RxJS implements this concept.

### Introducing the RxJS project

RxJS is the result of many efforts to manage the myriad of problems that manifest in asynchronous programming, outlined earlier. It’s an open source framework ported by Matthew Podwysocki from Rx.Net (Reactive Extensions for .Net), itself open source and created by Microsoft. RxJS has now evolved as a community-driven project owned by Ben Lesh from Netflix, sanctioned by Microsoft as RxJS 5. This latest version is a complete overhaul of the previous version with a brand-new architecture, a laser focus on performance, and drastic simplification of the API surface. It offers several distinct advantages over other JavaScript solutions, because it provides idiomatic abstractions to treat asynchronous data similar to how you would treat any source of synchronous data, like a simple array. You can obtain installation details in appendix A.

If you were to visit the main website for the Reactive Extensions project (http:// reactivex.io/), you’d find it defined as “an API for asynchronous programming with observable streams.” By the end of this chapter, you’ll be able to parse out exactly what this means. We’ll demystify this concept and put you on the right path to tackle the problems presented in this book.

Let’s see what thinking in streams looks like more concretely in RxJS. In figure 1.9, we show a simple breakdown of a stream (or pipeline) approach to handling data. A pipeline is a series of logic blocks that will be executed, in order, when data becomes available. 4 On the left side of figure 1.9 are the data sources, which produce various forms of data to be consumed by an application. And on the right are the data consumers, the entities that subscribe to (or listen for) these events and will do something with data they receive, such as present it on a chart or save it to a file. In the middle is the data pipeline. During this middle step, data that’s coming from any of the data sources that are being observed is filtered and processed in different ways so that it can be more easily consumed by the consumers.

Figure 1.9 A generic data-processing pipeline deals with a constant stream of asynchronous data, moving it from a producer (for example, a user clicking the mouse) to a consumer (code that reacts to the click). The pipeline will process data before it’s passed to the consumer for consumption.

You can subscribe to streams and implement functions within the pipeline that will be called (therefore react) when an event occurs (it’s this pipeline component where the principles of FP will come into play, as you’ll learn about in chapter 2).

> DEFINITION - A stream is nothing more than a sequence of events over time.

A popular example that you can relate to would be an Excel spreadsheet. You can easily bind functions onto cells that subscribe to the values of other cells and respond in real time as soon as any of the bounded cells change. A stream is an abstract concept that works exactly like this, so we’ll slowly wind up to it and break it down starting with some popular constructs you’re familiar with.

### Everything is a stream

The concept of a stream can be applied to any data point that holds a value; this ranges from a single integer to bytes of data received from a remote HTTP call. RxJS provides lightweight data types to subscribe to and manage streams as a whole that can be passed around as first-class objects and combined with other streams. Learning how to manipulate and use streams is one of the central topics of this book. At this point, we haven’t talked about any specific RxJS objects; for now, we’ll assume that an abstract data type, a container called Stream, exists. You can create one from a single value as such:

```
Stream(42);
```

At this point, this stream remains dormant and nothing has actually happened, until there’s a subscriber (or observer) that listens for it. This is very different from Promises, which execute their operations as soon as they’re created. Instead, streams are lazy data types, which means that they execute only after a subscriber is attached. In this case, the value 42, which was lifted into the stream context, navigates or propagates out to at least one subscriber. After it receives the value, the stream is completed:

```
// Using a simple function that will be called with each event in the stream
Stream(42).subscribe(
  val => {
    console.log(val); //-> prints 42
  }
);
```

> Observer pattern

> Behind RxJS is a fine-tuned observer design pattern. It involves an object (the subject), which maintains a list of subscribers (each an observer) that are notified of any state changes. This pattern has had many applications, especially as an integral part of the model-view-controller (MVC) architecture where the view layer is constantly listening for model changes. But the rudimentary observer pattern has its drawbacks because of memory leaks related to improper disposal of observers. You can learn more about this in the famous book Design Patterns: Elements of Reusable Object- Oriented Software, known casually as the Gang of Four book.

> RxJS draws inspiration from this pattern for its publish-subscribe methodology targeted at asynchronous programs but adds a few extra features out of the box, like signals that indicate when a stream has completed, lazy initialization, cancellation, resource management, and disposal. Later on, we’ll talk about the components of an RxJS stream.

> ---

> a. Gamma, Helm, Johnson, and Vlissides (Addison-Wesley, 1977, Oxford University Press).

Furthermore, you can extend this example to a sequence of numbers

```
Stream(1, 2, 3, 4, 5).subscribe(
  val => {
    console.log(val);
  }
);
//-> 1
     2
     3
     4
     5
```

or even arrays:

```
// Streams also support the Array.map() and Array.filter() functions introduced in ES5 to process the contents within the array.
Stream([1, 2, 3, 4, 5])
  .filter(num => (num % 2) === 0)
  .map(num => num * num)
  .subscribe(
    val => {
      console.log(val);
    }
  );
//-> 4
     16
```

In this example, the set of operations that occurs between the creation of the producer of the stream (in this case, the array) and the consumer (the function that logs to the console) is what we’ll refer to as the pipeline (we’ll expand on these concepts shortly). The pipeline is what we’ll study thoroughly in this book and is what allows you to transform a given input into the desired output. In essence, it’s where your business logic will be executed, as outlined in figure 1.10.

Figure 1.10 A simple producer (an array of numbers) that emits events linearly. These events are submitted through the pipeline and transformed. The final data is then sent to all subscribers to be consumed.

Up until now, we’ve created streams from static data sources: numbers (or strings), sequences, and arrays. But the power of RxJS extends beyond that with the ability to treat dynamic data sources in exactly the same way, as if time didn’t factor into the equation.

### Abstracting the notion of time from your programs

Indeed, time is of the essence. The hardest part of asynchronous code is dealing with latency and wait time. You saw earlier how callbacks and Promises can be used to cope with these concerns, each with their own limitations. RxJS brings this notion of continuous sequences of events over time as a first-class citizen of the language—finally, a true event subsystem for JavaScript. In essence, this means that RxJS abstracts over time under the same programming model regardless of source, so that you can transform your data as if your code was completely linear and synchronous. This is brilliant because you now can process a sequence of mouse events just as easily as processing an array of numbers.

Looking at figure 1.11, you can see that streams are analogous to a real-world monthly magazine subscription. Your subscription to the magazine is actually a collection of magazines that are separated by time; that is, there are 12 magazines annually, but you receive only one every month. Upon receiving a magazine, you usually perform an action on it (read it or throw it away). There are additional cases that you can also consider, such as the time between magazine deliveries being zero, whereby you would receive all the magazines at once, or there might be no magazines (and someone would be getting an angry email). In all these cases, because you perform the action only upon receiving the magazine, you can think of this process as reactive (because you’re reacting to receiving a magazine). A non-reactive version of this would be going to a newspaper stall at the airport. Here, you can also find magazines, but now you won’t receive additional magazines, only the ones that you buy at the stall. In practice, this would mean that you receive updates only when you happen to be near a magazine stand rather than every time a new magazine becomes available.

Figure 1.11 Not only does RxJS handle sequential events, but using the same programming model, it can just as easily work with asynchronous events (bound by time). This means that the same level of reasoning applied to linear programs can also be applied to non-linear programs with latency and wait times.

Rx allows you to take this magazine subscription metaphor and apply it to a wide range of use cases: loading files from disk or over a network, processing user input, or handling real-time services like RSS and Twitter feeds. Following the same examples as before, with RxJS you can consume a stream of time-based asynchronous sequences of events, just as you did with normal synchronous data:

```
// Using the well-known Array.filter() operator, this time with magazine subscriptions, to retrieve only the July edition
Stream(loadMagazines('/subscriptions/magazines'))
  .filter(magazine => magazine.month === 'July')
  .subscribe(
    magazine => {
      console.log(magazine.title);
      //-> prints Dr. Dobbs "Composing Reactive Animations"
    }
  );
```

These types of services produce data in real time at irregular intervals, and the data produced forms the foundation of an event stream. In the case of a service like Twitter, you can think of the Twitter API as a producer of tweets, of which some will be interesting and some not so much. In general, in most cases you’re interested in creating logic that processes the content of the tweet rather than diving into the intricacies of network communication. As we mentioned earlier, this logic is made up of several components, which we’ll look at in more detail.

### Components of an Rx stream

The RxJS stream is made up of several basic components, each with specific tasks and lifetimes with respect to the overall stream. You saw some examples of these earlier, and now we’ll introduce them more formally:

* Producers
* Consumers
* Data pipeline
* Time

PRODUCERS

Producers are the sources of your data. A stream must always have a producer of data, which will be the starting point for any logic that you’ll perform in RxJS. In practice, a producer is created from something that generates events independently (anything from a single value, an array, mouse clicks, to a stream of bytes read from a file). The observer pattern defines producers as the subject; in RxJS, we call them observables, as in something that’s able to be observed.

Observables are in charge of pushing notifications, so we refer to this behavior as fire-and-forget, which means that we’ll never expect the producer to be involved in the processing of events, only the emission of them.

> TC-39 OBSERVABLE SPEC - The use of observables has proven to be so successful from the previous version of the library (RxJS 4) that a proposal has been made to include it in the next major release of JavaScript. 5 Fortunately, RxJS 5 follows this proposal closely to remain completely compatible.

CONSUMERS

To balance the producer half of the equation, you must also have a consumer to accept events from the producer and process them in some specific way. When the consumer begins listening to the producer for events to consume, you now have a stream, and it’s at this point that the stream begins to push events; we’ll refer to a consumer as an observer.

Streams travel only from the producer to the consumer, not the other way around. In other words, a user typing on the keyboard produces events that flow down to be consumed by some other process. This means that part of understanding of how to think in streams will mean understanding how to think about parts of an application as upstream or downstream to determine the direction in which the data will flow. With respect to RxJS, a stream will always flow from an upstream observable to a downstream observer, and both components are loosely coupled, which increases the modularity of your application, as shown in figure 1.12.

Figure 1.12 Events always move from observables to observers and never the other way around.

For instance, a keyboard event handler would be upstream because it would only produce events, not consume them, whereas code that should perform logic based on key presses would be downstream. At a fundamental level, a stream will only ever require the producer and the consumer. Once the latter is able to begin receiving events from the former, you have effectively created a stream. Now what can you do with this data? All of that happens within the data pipeline.

DATA PIPELINE

One advantage of RxJS is that you can manipulate or edit the data as it passes from the producer to the consumer. This is where the list of methods (known as observable operators) comes into play. Manipulating data en route means that you can adapt the output of the producer to match the expectations of the consumer. Doing so promotes a separation of concerns 6 between the two entities, and it’s a big win for the modularity of your code. This design principle is typically extremely hard to accomplish in large-scale JavaScript applications, but RxJS facilitates this model of design.

TIME

The implicit factor behind all of this is time. For everything RxJS there’s always an underlying concept of time, which you can use to manipulate streams. The time factor permeates all the components we’ve discussed so far. It’s an important and abstract concept to grasp, so we’ll look at it in detail in later chapters. For now, you need only understand that time need not always run at normal speed, and you can build streams that run slower or faster depending on your requirements. Luckily, this won’t be an issue if you decide to use RxJS. Figure 1.13 provides a visualization of the parts of the RxJS stream.

Figure 1.13 Sample code highlighting the different components of a stream

If you pay close attention to the structure of a stream, you’ll notice that this closely resembles the pattern used in Promises. What started out as a nested callback “pyramid of doom”

```
ajax(
  '<host1>/items',
  items => {
    items.forEach(item => {
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    });
  }
);
```

was drastically improved using Promises:

```
ajax('<host1>/items')
  .then(items =>
    items.map(item => ajax(`<host2>/data/${item.getId()}/info`)
  )
  .then(promises =>
    Promise.all(promise)
  )
  .then(dataInfo =>
    ajax(`<host3>/data/files/${dataInfo.files}`)
  )
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

And now, streams extend this behavior with powerful operators that break this down even further:

```
// Streams can also compose other streams.
Stream(ajax('<host1>/items')
  .streamMap(item =>
    Stream(ajax(`<host2>/data/${item.getId()}/info`)))
  .streamMap(dataInfo =>
    Stream(ajax(`<host3>/data/files/${dataInfo.files}`)))
  .subscribe(processFiles);
```

Remember that the Stream object here is merely an abstract artifact designed to show you how the paradigm works. In this book, you’ll learn to use the actual objects that implement these abstract concepts to design your applications using a functional and reactive model. But RxJS doesn’t obligate you to use only a single paradigm; it’s often the combination of paradigms that creates the most flexible and maintainable designs.

## 响应式和其他编程范式

您在编程生涯中遇到的每一种新范式都需要您修改你的思维方式以适应不同的语言表达方式。举个例子，传统的面向对象编程范式将对象的状态置于对象中，这是对象抽象的中心单元，范式的复杂性来自于彼此交互时产生的交互。类似的，FP函数式编程范式将行为作为所有事物的中心，以函数作为主要工作单位的功能。另一方面，响应式编程要求您将数据视为变化的不断流动的流，而不是复合数据类型或所有应用程序状态的集合。

现在你一定想知道是否我们只能选择其中一种范式？或者我们是否能将它整合在一套代码体系中？美妙的是我们可以将他们一起使用，很多优秀的同行已经帮我们验证了这一点，换句话说，RxJS 并不强迫使用者使用固定的开发或者设计模式，他是一个非侵入型的库。正是由于这一优点，他可以和大量的库协同使用。正如本书接下来的内容所描述的，在大多数情况下，RxJS只关心将现有事件流（如 DOM 事件处理程序）适配为可观察的对象。RxJS 提供了许多我们可以直接在项目中使用的方法，它甚至可以支持不寻常的设计模式，例如与 React 或 Redux 这样的库一起使用（您将在最后一章中看到）。

在实践中，你们可以使用 OOP 面向对象范式来抽象你们的领域模型同时使用强大的响应函数式编程来驱动业务的行为和事件。当涉及到事件管理的时候，你们就会发现在代码中你们需要使用到Rx，这是本书的一个重要的主题。不像OOP将状态和数据保存在变量或者集合中，响应式编程的状态是临时的，这意味着数据将不会被持久化而是通过流传递给订阅事件的消费者手中，这使得事件处理变得可追溯并方便测试。

另一个值得注意不同的是用多种编程范式的的编程风格。一方面，OOP 面向对象编程通常是命令式的变成风格，换句话说，我们我们实例化了一个对象，通过对对象进行有些的状态改变来描述这些对象的交互和变化，以实现我们的需要的解决方案。

另一方面，Rxjs 鼓励我们使用声明式的编程风格，这要求我们的代码主要描述我们需要完成什么而不是我们如何完成。RxJS遵循函数式编程的原则采用简单的声明式设计.设计者不再需要创建变量来跟踪回调的进度，或者担心会无意中破坏导致副作用的封闭外部状态。此外，使用 RxJS，可以轻松管理多个数据流，当有需要的时候进行过滤和转换。通过创建可以链接在一起的操作，还可以流畅地创建逻辑管道，表述起来像：“当我收到七月份的杂志时，通知我。

在这个章节，我们学习了 RxJS 如何充分使用使用可观察对象（流）优雅地将函数式范式和响应式范式结合在一个简单的计算模型中，可观察物是纯粹的，没有副作用，具有强大的流操作函数和转化函数，可以让您通过异步操作优雅地构建业务逻辑。在学习的过程中，我们选择保留代码抽象，因为 RxJS 提出了很多新的概念，我们会在后续新的章节中详细说明。但是，我们将很快提升对库的全面的理论和实践理解，以便您可以立即在工作中或在您的个人项目上应用RxJS。现在是时候开始真正思考流，这就是下一章的主题。

## 总结

异步代码实现的难点在于现有的编程模式很难扩展到复杂的业务行为。

回调函数和 Promises 可用于处理异步代码，但是当针对由重复的按钮单击或鼠标移动生成的大流时，它们具有许多限制。

RxJS 是一种可以更简洁和声明式地处理随大量时序性数据的响应式解决方案。学习 RxJS 需要一个范式转变的过程，需要理解流中的数据在传播中变化，无论数据流是否具有时序性，这种编程模型的流始终产生自生产者(observable),通过管道流向消费者（observer）。