---
title: Thinking reactively
type: guide
order: 101
---

本章节覆盖
* 比较异步 JavaScript 的回调(callbacks)和基于 Promise(Promise-based)的解决方案
* 使用流(streams)，来对静态数据、动态数据，和时间限制(time-bound)的数据进行建模
* 使用可观察的流(observable streams)，以一种函数式的方式，来处理无时间限制(unbounded)的数据
* 考虑如何响应式地处理异步数据流组合

现在，在世界上某个地方，有人刚刚创建了一个的推文、股票价格刚刚下降、以及一个鼠标刚刚移动。这琐碎的数据点亮了互联网，并通过遍及全球的半导体传播到随处可见的地方。大量的数据在所有互相连接的设备间传递。这与你有什么关系？当你将代码推送到生产环境中时，此时将会在你的 JavaScript 应用程序中的管道上触发事件，这些事件需要预先做好准备，以及进行有效地处理。这产生了两个关键的挑战：可扩展性(scalability)和延迟(latency)。

随着接收到越来越多的数据，应用程序消耗或需要的内存量，将呈线性增长，或者，在最坏的情况下，将呈指数增长。这是可扩展性(scalability)的经典问题，并且尝试一次处理它，必定会导致用户界面（UI - user interface）变得无响应。按钮可能不再似乎起作用，梦幻般动画将变得拖沓，浏览器甚至可能会将页面标记为终止，这对于现代 web 用户来说是不可接受的。

这个问题虽然原本就有，然而，近年来，随着 JavaScript 应用程序需要处理的事件和数据的数量规模呈指数级增长，这就成为了新的问题。数据量太大，不能轻易地取出和存储在内存中以供使用。作为替代方案，我们必须建议从远程位置异步获取数据的方式，从而导致互联软件系统面临的另一个巨大挑战：延迟(latency)，会导致很难表达为代码。

虽然现代系统架构已经极大改善，包括更快的网络设备和高并发处理，然而，随着远程数据的复杂性增加，用于处理数据的库(library)和方式却并没有获得相应的发展。例如，当涉及从服务器获取数据或运行延迟计算时，我们大多数人仍然依赖回调(callbacks)的使用，当业务规则演变和变化时，又或者我们要解决的问题所涉及的数据不在一处，而是在几处不同的远程位置时，回调(callbacks)方式很快就将应用程序代码变得一团混乱。

解决方案不只是在于使用哪个库(library)，而是应该考虑此类问题的最佳配套范式。在本书中，你将首先了解两种新兴范式的基本原理：函数式编程（FP - functional programming）和响应式编程（RP - reactive programming）。令人兴奋的是，将两种范式组合在一起后的函数式响应编程（FRP - functional reactive programming），以及最终体现这种编程思维的代码，被称为 RxJS（或称为 rx.js）的库，这是有效处理异步(asynchronous)和基于事件的数据源(event-based data sources)的最佳配方。

我们规划的路线图包括多个部分。首先，我们会引导你去理解响应式的原则、当前的解决方案、这些方案的缺点，以及 RxJS 是如何改进的。怀着发现新事物的心态，你会深入了解 RxJS 的具体细节，并了解核心操作符(operators)，可以让你以一种简洁优雅的方式，来表现那些复杂的、有时间限制(bounded)数据或无时间限制(unbounded)数据的数据流。你将了解到，为什么 RxJS 是适用于任何体量的、基于事件驱动的应用程序的理想选择。在学习旅途中，你会逐渐找出真实世界中相应例子，印证如何使用这个库(library)，来将多个远程数据、自动完成输入字段、拖放、处理用户输入、创建响应式 UI、并行处理等等组合在一起。这些示例旨在帮助你在学习 RxJS 的最重要功能时缩小范围。最后，我们会所有这些新技术将汇集在一起​​，构建一个使用 React/Rx 混合架构的完整规模的 web 应用程序，来结束你的旅程。

本章的目标是对本书将要学习的主题进行广泛的了解。我们将重点关注当前解决方案的局限性，并指出有关 RxJS 如何解决这些问题。此外，你会学习如何将思维方式转变为流(streams)（也称为事件的函数式序列），在 RxJS 的内部，流(streams)是通过我们熟悉的模式（例如，迭代器模式和观察者模式）实现的。最后，我们将探讨 RxJS 编写异步代码的优势，减少使用回调(callbacks)引起的逻辑纠缠，这也可以扩展到任何量级的数据。了解这两个世界之间的差异至关重要，所以让我们开始吧。

## 同步计算 vs 异步计算

简单来说，将运行时中的同步代码与异步代码，进行分离的主要因素是延迟时间(latency)，也称为等待时间(wait time)。将时序以显式的编码形式表现出来，会使人感到难以理解。当自己书写的代码的顺序，和运行时的代码执行顺序完全同步，你就会很容易根据这些顺序，编写出合适的、易于理解的代码：“执行这段程序，然后立即执行另一段程序”。

但是，如今的计算世界还没有提供如此奢侈的处理能力。在这个高度互联的计算世界中，在发送消息和接受响应的同一时刻，也代表着应用程序能够在此时间范围内，同时去处理一些其他事情，例如，响应用户输入、处理数字、或者更新 UI。这更像是“做这个（等待一段不确定的时间）；然后做另一个”。让应用程序闲置，然后等待数据库返回查询结果、等待网络的响应、或者是等待用户完成操作，这些传统方式是不可接受的，因此需要你利用异步执行，以使应用程序始终处于积极响应的状态。这里的主要问题是，在长时间运行的过程中，阻塞用户操作是否是可接受的。

### 同步代码造成的问题

每个代码块在执行时，都必须等待前一个代码块执行完成，这就是同步执行。无须怀疑，这是目前实现代码最容易的方式，因为你将代码执行的重任，放在用户那边，必须等待用户的处理完成，才会同步执行代码。许多系统仍然以这种方式运行着，例如 ATM、销售点系统和其他一些简易终端。以这种方式编写代码，会更加易于理解、维护和调试；不幸的是，由于 JavaScript 的单线程本质，任何长执行时(long-running)任务，例如等待 AJAX 执行返回、完成一个数据库操作，都不应该是同步进行。这样做会造成非常糟糕的用户体验，因为整个应用程序都在等待数据加载过程中闲置，并浪费宝贵的计算循环(computing cycles)，等待期间还可以直接执行其他代码。这也将阻塞下一个执行过程中，那些你期望执行的所有其他任务，因为长时间的加载，从而导致不自然的应用程序体验，如图 1.1 所示。

在这种场景中，程序在处理 1 时产生一个阻塞调用(blocking call)，这意味着程序必须等待控制权重新返回给调用者(caller)（译者注：即 Program），以便可以继续执行处理 2。在查询机器和简易终端中，这种方式可能运行良好，但是，浏览器 UI 不应该以这种方式实现。不仅会造成糟糕的用户体验(user experience - UX)，而且在经过一定时间段后，浏览器可能会认为你的脚本无响应并终止。以下是一个「等待服务器响应，而导致应用程序阻塞」的 HTTP 请求的示例：

```
let items = blockingHttpCall('/data');
items.forEach(item => {
  // 处理每个 item
});
```

图 1.1 一个程序执行两个同步的处理(process)。这个场景中的，一个处理可以可以像函数调用一样简单，例如一个 I/O 处理，或者一个网络事务。当处理 1 执行时，就会阻塞其他处理执行。

更好的方式是，在等待响应(response)时，调用 HTTP 请求并执行其他操作。任务的长执行时(long-running)不是唯一的问题；就像我们之前提到的，鼠标移动还额外产生了快速连续的细粒度事件(fine-grained events)。无论是长等待时间(long wait time)，还是快速处理数百个细小的事件对象造成的等待，同步去处理所有这些造成的等待，将导致整个应用程序变得无响应。那么，你应该以哪种非阻塞(non-blocking)的方式，去处理这些类型的事件呢？幸运的是，JavaScript 提供了回调函数(callback functions)。

同步地加载服务器端数据，会停止程序执行。在当前，本质上数据并不重要；它只是与你的应用程序关联的一些通用示例数据。

### 通过使用回调函数，创建无阻塞代码

使用函数(function)作为回调(callback)，已经成为这么多年来，JavaScript 开发中的重要组成部分。到处都会用到这种方式，包括从鼠标点击、键盘输入，到处理远端 HTTP 请求、或者文件 I/O。JavaScript 作为一种单线程语言(single-threaded language)，需要这样一种结构，以保证适用于不同层面的场景。回调函数在创立之初，是用来解决完整操作的长执行时(long-running)的难题，允许你提供一个处理函数(handler function)，一旦数据准备就绪，JavaScript runtime 会调用此处理函数。与此同时，你的应用程序还能够继续执行其他的任务，如图 1.2 所示。

在图 1.2 中，JavaScript 中的回调函数，创建了一种控制反转(inversion of control)模式，即，等待合适的时机，触发处理函数回来调用应用程序，而不是应用程序直接调用函数。

和前面的代码不同，你不必等待阻塞的 HTTP 调用，使用异步（AJAX）请求的回调将创建一个控制反转，允许你的应用程序继续执行下一行代码。在这种意义下，控制反转是指，你的代码的某些部分接收来自运行时系统(runtime system)返回的控制流的方式。在这种情况下，当数据准备好可以被处理的时候，运行时(runtime)通过函数句柄(function handler)调用（或者将控制权返回给你），因此，这就是术语 callback 的由来。来看这段代码：

```
ajax(
  '/data', // 没有显式地返回值
  items => { // 回调函数声明
    // 在服务器获取数据之后，所有处理都在回调函数内部进行。
    items.forEach(item => {
      // 处理每个 item
    });
  }
);
beginUiRendering(); // 此函数在 AJAX 调用后立即开始执行。
```

回调函数允许你以异步的方式去执行代码，以便应用程序可以稍后再返回控制权给你。这样可以让程序在此期间，继续执行所有其他任务。在这个代码示例中，HTTP 请求函数在后台运行，并且立即将控制权返回给调用者，以便开始渲染 UI；只有在完全加载好 HTTP 响应后，才处理 items 的内容。这种行为是理想的，因为它释放了应用程序，以便继续处理其他后续任务（例如，加载网页的其余部分），如同当前示例所展示的那样。就像你将在本书中看到的，对于 I/O 绑定(I/O-bound)的运行方式（例如，从 web 或者数据库获取数据），使用异步代码是一种很好的设计。这样做的原因是，I/O 处理通常比所有其他类型的指令慢得多，所以我们允许它们在后台运行，因为它们的完成不依赖处理器循环(processor cycles)。

> 在 1.1.2 节的代码示例中，ajax() 的第二个参数是回调函数。在该代码中，如同本书的许多部分，我们使用了 ECMAScript 6 中的 lambda 表达式语法([1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions))，它提供了一种更简明扼要的调用函数方式。lambda 表达式也被称为箭头函数，与我们早已熟悉的匿名函数(anonymous function)调用类似。箭头函数和匿名函数的微小差别在于它内部的关键字 this 的指向。在极少数情况下，当 this 的值很重要时，我们会把它提取出来，并且改用匿名表达式。

### 理解时间和空间

当然，我们也可以停止应用程序，以等待异步函数响应，但是这样付出的是时间等待的代价。而同步的程序，我们可以直接推断出应用程序的状态，异步代码迫使我们要去推断出未来状态。这是什么意思呢？可以将状态简单地理解为，在任何时间点上，存储到变量中的所有信息的快照。通过顺序执行的语句(statement)，去创建和操作这些信息。同步代码可以被认为是一个以顺序的方式，一步接着一步地执行语句，就像图 1.3 所示。

图 1.3 同步代码是指，一步接着一步地、顺序地相继执行语句，每一步都依赖于前一步的执行。

在这个同步模型中，在任何一个时间节点上，都很容易确定变量的状态是什么，接下来会发生什么，这就是为什么同步代码会很容易编写和调试。但是，当每个任务具有不同的等待时间，或者在不同的时间完成的时候，很难保证它们协同运转。如果没有合适的方法和实践，那些无法预知终止时间的函数通常更难处理。当这种异步场景发生时，我们用于理解应用程序的心智模型，还需要相应地补偿这个额外维度。将图 1.3 与图 1.4 中的模型进行比较，不仅在垂直方向上，而且水平方向也有所扩展。

图 1.4 在异步执行中，按顺序调用的那些步骤不需要同时终止。因此，绝对无法保证的是，你能够在可以在步骤 2 中，使用依赖于步骤 1 中的数据。

此时此刻，如果步骤 1, 2 和 3 是互相独立的任务，那么以任何顺序执行它们都不是问题。但是，如果这些函数是共享所有全局状态的函数，那么它们的行为将由它们被调用的先后顺序或系统的全局状态决定。这些条件我们称之为外部副作用(side effect)，你将在第 2 章中了解更多信息；它们涉及需要读取或修改外部资源（如数据库，DOM，控制台等）的情况。具有外部副作用的函数，在以任意顺序运行时，无法保证最终的执行结果可靠。在函数式和响应式编程中，你将学习通过使用纯函数来最小化依赖外部带来的副作用，你将在本书中了解到，在处理异步代码时，这种方式是非常有利的。

所以，假设我们的函数是无外部副作用的，然而我们还有另一个重要的问题 - 时间。步骤 1, 2 和 3 可能会立即完成，也可能不完成，取决于具体运行机制的本质。主要的问题是我们如何保证，这些步骤以正确的顺序执行。由于你可能已经实现过很多次了，正确方式是将这些函数组合在一起，从而使上一个的输出成为下一个的输入，因此创建出一条链式的步骤。确保正确的步骤顺序的传统方法是，按序嵌套回调，并且应用程序的运行时(runtime)的模型类似于图 1.5。

图 1.5 为了保证步骤的正确顺序和异步调用的按序执行，每当长执行时(long-running)的操作终止时，我们就使用回调函数来接管应用程序的控制权。

毫无疑问，这种嵌套控制流程，比图 1.4 的同步线性模型难以理解。在图 1.5 中，步骤 1 首先执行，然后在完成时调用步骤 2；然后在完成时执行步骤 3，其余的步骤也依此类推。这表明，在这些步骤之间，存在时序依赖或时间耦合，这意味着，只有在上一个完成后，下一个才可以开始 - 这就像是将一条命令链。在这种情况下，回调函数用于响应之前触发的异步请求，并开始处理其数据。通常会用在执行顺序的 AJAX 请求时，但也可能用在那些掺杂了所有基于事件的系统中，无论是按键、鼠标移动、数据库读取和写入等；所有这些系统都会依赖回调。

### 回调(callback)是否变得无关紧要？

最简洁的答案是不。在处理与用户(users)或与外部服务(external services)的简单交互时，通过使用范式(paradigm)去解决基于事件(event-based)的代码或异步(asynchronous)的代码是没有必要的。如果你正在编写一个发出远端 HTTP 请求的简单脚本，RxJS 是大材小用，回调(callback)仍然是完美的解决方案。另一方面，当实现具有中高复杂度的状态机，例如动态用户界面(dynamic UI)或服务调度层(service orchestration)时，混合有函数式范式(functional paradigm)和响应式范式(reactive paradigm)的库(library)才能开始显耀发挥。其中一些例子可能需要协调几个业务流程的执行，这些业务流程需要使用多个微服务(microservices)，数据聚合(data mashups)，或者可能需要实现由页面上的多个小部件组成的富用户界面(rich UI)的功能，而这些小部件又彼此交互。

考虑从客户端加载来自不同远端服务器端点的数据的任务。要在它们之间进行协调，你需要几个互相嵌套的 AJAX 请求，其中每一步都包含着每个回调函数体(callback body)中的处理数据，以及使用这些数据去调用下一步的逻辑，如前面图 1.5 所示。以下是一个可能存在场景的解决方案，它需要使用三个回调函数组合在一起，来加载可能位于同一或不同主机(host)中的数据集，以及相关的元信息(meta-information)和文件：

```
ajax(
  '<host1>/items', // 加载要显示的所有 item
  items => {
    for (let item of items) {
      ajax(
        `<host2>/items/${item.getId()}/info`, // 对每个 item，都加载额外的元信息(meta-information)
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles); // 对每个元记录(meta record)，加载相关文件
        }
      );
    }
  }
);
beginUiRendering();
```

现在，尽管你可能认为这些（回调）代码看起来微不足道，但如果继续这种模式，我们将不断地陷入朝着水平方向嵌套调用 - 我们的模型开始朝着水平方向增长。这个趋势在 JavaScript 世界中被非正式地称为回调地狱(callback hell)，如果想要创建可维护且易于理解的程序，你需要不惜一切代价避免这种设计。这不仅仅是强调代码的简洁美学 - 将确保单独的异步操作，体现为毫无阅读难度的同步代码是很难的。同时这些代码中其实还有另一个隐藏的问题。你能猜出有什么问题吗？这个隐藏问题通常会出现于，在命令式代码块（类似 for...of）的同步工件中混杂着调用异步函数的代码。循环(loop)没有意识到这些调用中存在延迟，所以循环会不关心这些延迟调用而继续前进，这会很大程度上导致一些无法预测和难以诊断的错误。在这些情况下，可以通过在异步函数外部创建闭包来改善问题，以及使用 forEach() 而不是循环(loop)进行操作：

```
ajax(
  '<host1>/items',
  items => {
    items.forEach(item => { // 数组的 forEach() 方法会让每个 item 对象都处于正确的作用域中，从而让嵌套在函数内的 HTTP 调用获取到正确的 item。
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    });
  }
);
```

这也就是为什么在 RxJS 和一般的函数式编程(FP - functional programming)中，所有的循环都被消除的原因！相反，在第 4 章和第 5 章中，你将学习有关操作符(operators)的知识，使你能够利用纯函数来产生异步请求序列(sequences of asynchronous requests)，以保持所有的 information 变量都能够处于正确的作用域。回调的另一个很好的用法是，由基于 Node.js 事件触发器(event emitters) API 实现。接下来我们来了解事件触发器。

###  事件触发器(event emitters)

对于基于事件(event-based)的异步体系结构，事件触发器(event emitters)是一种很流行的机制。例如，DOM 就是最广为人知的事件触发器之一。在像 Node.js 这样的服务平台上，某些类型的对象会周期性地产生事件，这些事件又会产生函数调用。在 Node.js 中，EventEmitter 类(class)用于实现诸如 WebSocket I/O 或者文件读/写之类的 API，因此，如果你遍历目录然后找到关注的文件，某个对象就会发出(emit)引用此文件的事件，以便你执行后续任何额外的代码。

让我们实现一个简单的对象来稍微展示一下这个 API。考虑一个简单的计算器对象，可以发出(emit)像加法和减法这样的事件，你可以将任何自定义逻辑添加到这两个钩子函数(hook)中，如图1.6.

图 1.6 Node 触发器对象，其具体表现为一个简单的计算器，它暴露了两个事件：加法和减法

这里是一些计算器的加法事件和减法事件的代码：

```
const EventEmitter = require('events'); // 加载 events 模块

class Calculator extends EventEmitter {} // 创建一个自定义的触发器(emitter)

const calc = new Calculator();

// 处理加法事件(add event)
calc.addListener('add', (a, b) => {
  calc.emit('result’, a + b);
});

calc.addListener('subtract', (a, b) => {
  calc.emit('result', a - b);
});

calc.addListener('result', (result) => {
  console.log('Result: ' + result);
});

calc.emit('add', 2, 3); //-> 打印 'Result: 5'
calc.emit('subtract', 2, 3); //-> 打印 'Result: 1'
```

订阅一个事件触发器，是通过 addListener() 方法实现的，它允许你提供一个回调函数，以便在关注事件被触发的时候调用。不幸的是，与「使用回调(callback)处理来自多个组合资源的数据」的相比，事件触发器(event emitter)也具有所有相同的问题。总体而言，将嵌套的异步流组合起来是很困难的。

整个 JavaScript 社区在解决这些类型的问题方面取得了很大幅度的进步。借助于函数式编程(FP - functional programming)中出现的模式，你可以使用 ES6 提供的替代方案，也就是 Promise。

## Better callbacks with Promises

All hope is not lost; we promise you that. Promises are not part of the RxJS solution, but they work together perfectly well. JavaScript ES6 introduced Promises to represent any asynchronous computation that’s expected to complete in the future. With Promises, you can chain together a set of actions with future values to form a continuation. 2 A continuation is just a fancy term for writing callbacks and has a lot to do with the principle of Inversion of Control we referenced earlier. A continuation (a callback) allows the function to decide what it should do next, instead of indiscriminately waiting for a return value. They’re used heavily when iterating over arrays, tree structures, try/catch blocks, and, of course, asynchronous programming. So, the code you saw earlier -

```
ajax(
  '<host1>/items',
  items => {
    for (let item of items) {
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    }
  }
);
```

- is known to be continuation-passing style (CPS), because none of the functions are explicitly waiting for a return value. But as we mentioned, abusing this makes code hard to reason about. What you can do is to make continuations first-class citizens and actually define a concrete interpretation of what it means to “continue.” So, we introduce the notion of then: “Do X, then do Y,” to create code that reads like this:

```
Fetch all items, then // The key term “then” suggests time and sequence.
  For-each item fetch all files, then
    Process each file
```

This is where Promises come in. A Promise is a data type that wraps an asynchronous or long-running operation, a future value, with the ability for you to subscribe to its result or its error. A Promise is considered to be fulfilled when its underlying operation completes, at which point subscribers will receive the computed result. Because we can’t alter the value of a Promise once it’s been executed, it’s actually an immutable type, which is a functional quality we seek in our programs. Different Promise implementations exist based on the Promises/A+ protocol (see https:// promisesaplus.com/), and it’s designed to provide some level of error handling and continuations via the then() methods. Here’s how you can tackle the same example if you assume that ajax() returns Promises:

```
ajax('<host1>/items')
  .then(items =>
    items.forEach(item =>
      ajax(`<host2>/data/${item.getId()}/info`)
        .then(dataInfo =>
          ajax(`<host3>/data/files/${dataInfo.files}`)
        )
        .then(processFiles);
    )
  );
```

This looks similar to the previous statement! Being a more recent addition to the language with ES6 and inspired in FP design, Promises are more versatile and idiomatic than callbacks. Applying these functions declaratively - meaning your code expresses the what and not the how of what you’re trying to accomplish - into then blocks allows you to express side effects in a pure manner. We can refactor this to be more declarative by pulling out each function independently

```
let getItems = () => ajax('<host1>/items'); let getInfo = item => ajax(`<host2>/data/${item.getId()}/info`); let getFiles = dataInfo => ajax(`<host3>/data/files/${dataInfo.files}`);
```

and then use Promises to stitch together our asynchronous flow. We use the Promise .all() function to map an array of separate Promises into a single one containing an array of results:

```
getItems()
  .then(items => items.map(getInfo))
  .then(promises => Promise.all(promises))
  .then(infos => infos.map(getFiles))
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

The use of then() explicitly implies that there’s time involved among these calls, which is a really good thing. If any step fails, we can also have matching catch() blocks to handle errors and potentially continue the chain of command if necessary, as shown in figure 1.7.

Figure 1.7 Promises create a flow of calls chained by then methods. If the Promise is fulfilled, the chain of functions continues; otherwise, the error is delegated to the Promise catch block.

Of course, Promises also have shortcomings, or else we wouldn’t be talking about Rx. The drawback of using Promises is that they’re unable to handle data sources that produce more than one value, like mouse movements or sequences of bytes in a file stream. Also, they lack the ability to retry from failure - all present in RxJS. The most important downside, moreover, is that because Promises are immutable, they can’t be cancelled. So, for instance, if you use a Promise to wrap the value of a remote HTTP call, there’s no hook or mechanism for you to cancel that work. This is unfortunate because HTTP calls, based on the XmlHttpRequest object, can be aborted, 3 but this feature isn’t honored through the Promise interface. These limitations reduce their usefulness and force developers to write some of the cancellation logic themselves or seek other libraries.

Collectively, Promises and event emitters solve what are essentially the same problems in slightly different ways. They have different use cases (Promises for single-value returns like HTTP requests and event emitters for multiple-value returns like mouse click handlers), mostly because of their own implementation constraints, not because the use cases are so different. The result is that in many scenarios a developer must use both in order to accomplish their goal, which can often lead to disjointed and confusing code.

The problems of readability; hard-to-reason-about code; and the downsides of current technology that we’ve discussed so far aren’t the only reasons that we, as developers, need to worry about asynchronous code. In this next section, we’ll outline more concretely why we need to switch to a different paradigm altogether to tackle these issues head on.

For many years now, we’ve learned to use many JavaScript async libraries; everyone has their own preference, whether it be JQuery, Async.js, Q.js, or others, yet they all fall short one way or another. We believe that it’s not a matter of just choosing a library, but choosing the right paradigm for the job. By combining functional and reactive programming paradigms, RxJS will help you address the following issues:

* Familiar control flow structures (like for and while loops) with asynchronous functions don’t work well together because they’re not async aware; that is, they’re oblivious of wait time or latency between iterations.
* Error-handling strategies become easily convoluted when you begin nesting try/catch blocks within each callback. In chapter 7, we’ll approach error handling from a functional perspective. Also, if you want to implement some level of retry logic at every step, this will be incredibly difficult even with the help of other libraries.
* Business logic is tightly coupled within the nested callback structure you need to support. It’s plain to see that the more nested your code is, the harder it is to reason about. Functions that are deeply nested become entangled with other variables and functions, which is problematic in terms of readability and complexity. It would be ideal to be able to create reusable and modular components in order to have loosely coupled business logic that can be maintained and unit tested independently. We’ll cover unit testing with RxJS in chapter 9.
* You want to avoid excessive use of closures, but functions in JavaScript create a closure around the scope in which they’re declared. Nesting them means that you need to be concerned about not just the state of the variables passed in as arguments but also the state of all external variables surrounding each function declaration, causing side effects to occur. In the next chapter, you’ll learn how detrimental side effects can be and how FP addresses this problem. Side effects increase the cognitive load of the state of your application, making it virtually impossible to keep track of what’s going on in your programs. Throw a few loops and conditional if-else statements into the mix, and you’ll regret the day a bug occurs that impacts this functionality.
* It’s difficult to detect when events or long-running operations go rogue and need to be cancelled. Consider the case of a remote HTTP request that’s taking too long to process. Is the script unresponsive or is the server just slow? It would be ideal to have an easy mechanism to cancel events cleanly after some predetermined amount of time. Implementing your own cancellation mechanism can be very challenging and error prone even with the help of third-party libraries.
* One good quality of responsive design is to always throttle a user’s interaction with any UI components, so that the system isn’t unnecessarily overloaded. In chapter 4, you’ll learn how to use throttling and debouncing to your advantage. Manual solutions for achieving this are typically very hard to get right and involve functions that access data outside their local scope, which breaks the stability of your entire program.
* It’s rare to be concerned about memory management in JavaScript applications, especially client-side code. After all, the browser takes care of most of these low-level details. But as UIs become larger and richer, we can begin to see that lingering event listeners may cause memory leaks and cause the size of the browser process to grow. It’s true that this was more prevalent in older browsers; nevertheless, the complexity of today’s JavaScript applications is no match for the applications of years past.

This long list of problems can certainly overwhelm even the brightest developers. The truth of the matter is that the very paradigms that help us tackle these problems are hard to express in code, which is why a tool like RxJS is necessary to redefine our approach.

You learned that Promises certainly move the needle in the right direction (and RxJS integrates with Promises seamlessly if you feel the need to do so). But what you really need is a solution that abstracts out the notion of latency away from your code while allowing you to model your solutions using a linear sequence of steps through which data can flow over time, as shown in figure 1.8.

In essence, you need to combine the ability to decouple functionality like event emitters with the fluent design pattern of Promises, all into a single abstraction. Moreover, you need to work with both synchronous and asynchronous code, handle errors, discourage side effects, and scale out from one to a deluge of events. This is certainly a long laundry list of things to take care of.

As you think about this, ask yourself these questions: How can you write code as a linear sequence of steps that acts only after some event has occurred in the future? How do you combine it with other code that might have its own set of constraints? Your desire for synchronicity isn’t just about convenience; it’s what you’re used to. Unfortunately, most of the common language constructs that you use in synchronous code aren’t well suited for asynchronous execution. This lack of language support for things like async try/catch, async loops, and async conditionals means that developers must often roll their own. It’s not surprising that in the past few years, other people have asked the same questions and come together with the community at large to address these challenges, emerging as what’s known as the Reactive Extensions - we have arrived!

Figure 1.8 RxJS can treat asynchronous data flows with a programming model that resembles a simple chain of sequential steps.

## The Reactive Extensions for JavaScript

Reactive Extensions for JavaScript (RxJS) is an elegant replacement for callback or Promise-based libraries, using a single programming model that treats any ubiquitous source of events - whether it be reading a file, making an HTTP call, clicking a button, or moving the mouse - in the exact same manner. For example, instead of handling each mouse event independently with a callback, with RxJS you handle all of them combined.

As you’ll learn in chapter 9, RxJS is also inherently robust and easy to test with a vibrant community to support it. The power of RxJS derives from being built on top of the pillars of functional and reactive programming, as well as a few popular design patterns such as observer and iterator that have been used successfully for years. Certainly, RxJS didn’t invent these patterns, but it found ways to use them within the context of FP. We’ll discuss FP and its role in RxJS further in the next chapter; in order to take full advantage of this framework, the key takeaway from this section is that you must learn to think in terms of streams.

### Thinking in streams: data flows and propagation

Whether you deal with thousands of key presses, movement events, touch gestures, remote HTTP calls, or single integers, RxJS treats all of these data sources in exactly the same way, which we’ll refer to as data streams from now on.

> Traditionally, the term stream was used in programming languages as an abstract object related to I/O operations such as reading a file, reading a socket, or requesting data from an HTTP server. For instance, Node.js implements readable, writable, and duplex streams for doing just this. In the RP world, we expand the definition of a stream to mean any data source that can be consumed.

Reactive programming entails a mental shift in the way you reason about your program’s behavior, especially if you come from an imperative background. We’ll illustrate this shift in mindset with a simple exercise:

```
let a = 20;
let b = 22;
let c = a + b; //-> 42

a = 100;
c = ?
```

You can easily predict the value of c in this case: 42. The fact that we changed a didn’t have any influence on the value of c. In other words, there’s no propagation of change. This is the most important concept to understand in reactive programming. Now we’ll show you a pseudo JavaScript implementation of this:

```
A$ = [20]; B$ = [22]; // Creates a stream initialized with the value 22

C$ = A$.concat(B$).reduce(adder); //-> [42] // Concatenates both streams and applies an adder function to get a new container with 42

A$.push(100); // Pushes a new value into A$
C$ = ?
```

First, we’ll explain some of the notation we use here. Streams are containers or wrappers of data very similar to arrays, so we used the array literal notation [] to symbolize this. Also, it’s common to use the $ suffix to qualify variables that point to streams. In the RxJS community, this is known as Finnish Notation, attributed to Andre Staltz, who is one of the main contributors of RxJS and Finnish.

We created two streams, A$ and B$, with one numerical value inside each. Because they’re not primitive objects in JavaScript or have a plus (+) overloaded operator, we need to symbolize addition by concatenating both streams and applying an operator method like reduce with an adder function (this should be somewhat familiar to you if you’ve worked with these array methods). This is represented by C$.

JavaScript ES5 introduced new array methods, known as the array extras, which enable some level of native support for FP. These include map, reduce, filter, some, every, and others.

> ARRAY EXTRAS - What happens to C$ if the value 100 is pushed onto A$? In an imperative program, nothing will actually happen except that A$ will have an extra value. But in the world of streams, where there’s change propagation, if A$ receives a new value (a new event), this state is pushed through any streams that it’s a part of. In this case, C$ gets the value 122. Confused yet? Reactive programming is oriented around data flows and propagation. In this case, you can think of C$ as an always-on variable that reacts to any change and causes actions to ripple through it when any constituent part changes. Now let’s see how RxJS implements this concept.

What happens to C$ if the value 100 is pushed onto A$? In an imperative program, nothing will actually happen except that A$ will have an extra value. But in the world of streams, where there’s change propagation, if A$ receives a new value (a new event), this state is pushed through any streams that it’s a part of. In this case, C$ gets the value 122. Confused yet? Reactive programming is oriented around data flows and propagation. In this case, you can think of C$ as an always-on variable that reacts to any change and causes actions to ripple through it when any constituent part changes. Now let’s see how RxJS implements this concept.

### Introducing the RxJS project

RxJS is the result of many efforts to manage the myriad of problems that manifest in asynchronous programming, outlined earlier. It’s an open source framework ported by Matthew Podwysocki from Rx.Net (Reactive Extensions for .Net), itself open source and created by Microsoft. RxJS has now evolved as a community-driven project owned by Ben Lesh from Netflix, sanctioned by Microsoft as RxJS 5. This latest version is a complete overhaul of the previous version with a brand-new architecture, a laser focus on performance, and drastic simplification of the API surface. It offers several distinct advantages over other JavaScript solutions, because it provides idiomatic abstractions to treat asynchronous data similar to how you would treat any source of synchronous data, like a simple array. You can obtain installation details in appendix A.

If you were to visit the main website for the Reactive Extensions project (http:// reactivex.io/), you’d find it defined as “an API for asynchronous programming with observable streams.” By the end of this chapter, you’ll be able to parse out exactly what this means. We’ll demystify this concept and put you on the right path to tackle the problems presented in this book.

Let’s see what thinking in streams looks like more concretely in RxJS. In figure 1.9, we show a simple breakdown of a stream (or pipeline) approach to handling data. A pipeline is a series of logic blocks that will be executed, in order, when data becomes available. 4 On the left side of figure 1.9 are the data sources, which produce various forms of data to be consumed by an application. And on the right are the data consumers, the entities that subscribe to (or listen for) these events and will do something with data they receive, such as present it on a chart or save it to a file. In the middle is the data pipeline. During this middle step, data that’s coming from any of the data sources that are being observed is filtered and processed in different ways so that it can be more easily consumed by the consumers.

Figure 1.9 A generic data-processing pipeline deals with a constant stream of asynchronous data, moving it from a producer (for example, a user clicking the mouse) to a consumer (code that reacts to the click). The pipeline will process data before it’s passed to the consumer for consumption.

You can subscribe to streams and implement functions within the pipeline that will be called (therefore react) when an event occurs (it’s this pipeline component where the principles of FP will come into play, as you’ll learn about in chapter 2).

> DEFINITION - A stream is nothing more than a sequence of events over time.

A popular example that you can relate to would be an Excel spreadsheet. You can easily bind functions onto cells that subscribe to the values of other cells and respond in real time as soon as any of the bounded cells change. A stream is an abstract concept that works exactly like this, so we’ll slowly wind up to it and break it down starting with some popular constructs you’re familiar with.

### Everything is a stream

The concept of a stream can be applied to any data point that holds a value; this ranges from a single integer to bytes of data received from a remote HTTP call. RxJS provides lightweight data types to subscribe to and manage streams as a whole that can be passed around as first-class objects and combined with other streams. Learning how to manipulate and use streams is one of the central topics of this book. At this point, we haven’t talked about any specific RxJS objects; for now, we’ll assume that an abstract data type, a container called Stream, exists. You can create one from a single value as such:

```
Stream(42);
```

At this point, this stream remains dormant and nothing has actually happened, until there’s a subscriber (or observer) that listens for it. This is very different from Promises, which execute their operations as soon as they’re created. Instead, streams are lazy data types, which means that they execute only after a subscriber is attached. In this case, the value 42, which was lifted into the stream context, navigates or propagates out to at least one subscriber. After it receives the value, the stream is completed:

```
// Using a simple function that will be called with each event in the stream
Stream(42).subscribe(
  val => {
    console.log(val); //-> prints 42
  }
);
```

> Observer pattern

> Behind RxJS is a fine-tuned observer design pattern. It involves an object (the subject), which maintains a list of subscribers (each an observer) that are notified of any state changes. This pattern has had many applications, especially as an integral part of the model-view-controller (MVC) architecture where the view layer is constantly listening for model changes. But the rudimentary observer pattern has its drawbacks because of memory leaks related to improper disposal of observers. You can learn more about this in the famous book Design Patterns: Elements of Reusable Object-Oriented Software, known casually as the Gang of Four book.

> RxJS draws inspiration from this pattern for its publish-subscribe methodology targeted at asynchronous programs but adds a few extra features out of the box, like signals that indicate when a stream has completed, lazy initialization, cancellation, resource management, and disposal. Later on, we’ll talk about the components of an RxJS stream.

> ---

> a. Gamma, Helm, Johnson, and Vlissides (Addison-Wesley, 1977, Oxford University Press).

Furthermore, you can extend this example to a sequence of numbers

```
Stream(1, 2, 3, 4, 5).subscribe(
  val => {
    console.log(val);
  }
);
//-> 1
     2
     3
     4
     5
```

or even arrays:

```
// Streams also support the Array.map() and Array.filter() functions introduced in ES5 to process the contents within the array.
Stream([1, 2, 3, 4, 5])
  .filter(num => (num % 2) === 0)
  .map(num => num * num)
  .subscribe(
    val => {
      console.log(val);
    }
  );
//-> 4
     16
```

In this example, the set of operations that occurs between the creation of the producer of the stream (in this case, the array) and the consumer (the function that logs to the console) is what we’ll refer to as the pipeline (we’ll expand on these concepts shortly). The pipeline is what we’ll study thoroughly in this book and is what allows you to transform a given input into the desired output. In essence, it’s where your business logic will be executed, as outlined in figure 1.10.

Figure 1.10 A simple producer (an array of numbers) that emits events linearly. These events are submitted through the pipeline and transformed. The final data is then sent to all subscribers to be consumed.

Up until now, we’ve created streams from static data sources: numbers (or strings), sequences, and arrays. But the power of RxJS extends beyond that with the ability to treat dynamic data sources in exactly the same way, as if time didn’t factor into the equation.

### Abstracting the notion of time from your programs

Indeed, time is of the essence. The hardest part of asynchronous code is dealing with latency and wait time. You saw earlier how callbacks and Promises can be used to cope with these concerns, each with their own limitations. RxJS brings this notion of continuous sequences of events over time as a first-class citizen of the language - finally, a true event subsystem for JavaScript. In essence, this means that RxJS abstracts over time under the same programming model regardless of source, so that you can transform your data as if your code was completely linear and synchronous. This is brilliant because you now can process a sequence of mouse events just as easily as processing an array of numbers.

Looking at figure 1.11, you can see that streams are analogous to a real-world monthly magazine subscription. Your subscription to the magazine is actually a collection of magazines that are separated by time; that is, there are 12 magazines annually, but you receive only one every month. Upon receiving a magazine, you usually perform an action on it (read it or throw it away). There are additional cases that you can also consider, such as the time between magazine deliveries being zero, whereby you would receive all the magazines at once, or there might be no magazines (and someone would be getting an angry email). In all these cases, because you perform the action only upon receiving the magazine, you can think of this process as reactive (because you’re reacting to receiving a magazine). A non-reactive version of this would be going to a newspaper stall at the airport. Here, you can also find magazines, but now you won’t receive additional magazines, only the ones that you buy at the stall. In practice, this would mean that you receive updates only when you happen to be near a magazine stand rather than every time a new magazine becomes available.

Figure 1.11 Not only does RxJS handle sequential events, but using the same programming model, it can just as easily work with asynchronous events (bound by time). This means that the same level of reasoning applied to linear programs can also be applied to non-linear programs with latency and wait times.

Rx allows you to take this magazine subscription metaphor and apply it to a wide range of use cases: loading files from disk or over a network, processing user input, or handling real-time services like RSS and Twitter feeds. Following the same examples as before, with RxJS you can consume a stream of time-based asynchronous sequences of events, just as you did with normal synchronous data:

```
// Using the well-known Array.filter() operator, this time with magazine subscriptions, to retrieve only the July edition
Stream(loadMagazines('/subscriptions/magazines'))
  .filter(magazine => magazine.month === 'July')
  .subscribe(
    magazine => {
      console.log(magazine.title);
      //-> prints Dr. Dobbs "Composing Reactive Animations"
    }
  );
```

These types of services produce data in real time at irregular intervals, and the data produced forms the foundation of an event stream. In the case of a service like Twitter, you can think of the Twitter API as a producer of tweets, of which some will be interesting and some not so much. In general, in most cases you’re interested in creating logic that processes the content of the tweet rather than diving into the intricacies of network communication. As we mentioned earlier, this logic is made up of several components, which we’ll look at in more detail.

### Components of an Rx stream

The RxJS stream is made up of several basic components, each with specific tasks and lifetimes with respect to the overall stream. You saw some examples of these earlier, and now we’ll introduce them more formally:

* Producers
* Consumers
* Data pipeline
* Time

PRODUCERS

Producers are the sources of your data. A stream must always have a producer of data, which will be the starting point for any logic that you’ll perform in RxJS. In practice, a producer is created from something that generates events independently (anything from a single value, an array, mouse clicks, to a stream of bytes read from a file). The observer pattern defines producers as the subject; in RxJS, we call them observables, as in something that’s able to be observed.

Observables are in charge of pushing notifications, so we refer to this behavior as fire-and-forget, which means that we’ll never expect the producer to be involved in the processing of events, only the emission of them.

> TC-39 OBSERVABLE SPEC - The use of observables has proven to be so successful from the previous version of the library (RxJS 4) that a proposal has been made to include it in the next major release of JavaScript. 5 Fortunately, RxJS 5 follows this proposal closely to remain completely compatible.

CONSUMERS

To balance the producer half of the equation, you must also have a consumer to accept events from the producer and process them in some specific way. When the consumer begins listening to the producer for events to consume, you now have a stream, and it’s at this point that the stream begins to push events; we’ll refer to a consumer as an observer.

Streams travel only from the producer to the consumer, not the other way around. In other words, a user typing on the keyboard produces events that flow down to be consumed by some other process. This means that part of understanding of how to think in streams will mean understanding how to think about parts of an application as upstream or downstream to determine the direction in which the data will flow. With respect to RxJS, a stream will always flow from an upstream observable to a downstream observer, and both components are loosely coupled, which increases the modularity of your application, as shown in figure 1.12.

Figure 1.12 Events always move from observables to observers and never the other way around.

For instance, a keyboard event handler would be upstream because it would only produce events, not consume them, whereas code that should perform logic based on key presses would be downstream. At a fundamental level, a stream will only ever require the producer and the consumer. Once the latter is able to begin receiving events from the former, you have effectively created a stream. Now what can you do with this data? All of that happens within the data pipeline.

DATA PIPELINE

One advantage of RxJS is that you can manipulate or edit the data as it passes from the producer to the consumer. This is where the list of methods (known as observable operators) comes into play. Manipulating data en route means that you can adapt the output of the producer to match the expectations of the consumer. Doing so promotes a separation of concerns 6 between the two entities, and it’s a big win for the modularity of your code. This design principle is typically extremely hard to accomplish in large-scale JavaScript applications, but RxJS facilitates this model of design.

TIME

The implicit factor behind all of this is time. For everything RxJS there’s always an underlying concept of time, which you can use to manipulate streams. The time factor permeates all the components we’ve discussed so far. It’s an important and abstract concept to grasp, so we’ll look at it in detail in later chapters. For now, you need only understand that time need not always run at normal speed, and you can build streams that run slower or faster depending on your requirements. Luckily, this won’t be an issue if you decide to use RxJS. Figure 1.13 provides a visualization of the parts of the RxJS stream.

Figure 1.13 Sample code highlighting the different components of a stream

If you pay close attention to the structure of a stream, you’ll notice that this closely resembles the pattern used in Promises. What started out as a nested callback “pyramid of doom”

```
ajax(
  '<host1>/items',
  items => {
    items.forEach(item => {
      ajax(
        `<host2>/items/${item.getId()}/info`,
        dataInfo => {
          ajax(`<host3>/files/${dataInfo.files}`, processFiles);
        }
      );
    });
  }
);
```

was drastically improved using Promises:

```
ajax('<host1>/items')
  .then(items =>
    items.map(item => ajax(`<host2>/data/${item.getId()}/info`)
  )
  .then(promises =>
    Promise.all(promise)
  )
  .then(dataInfo =>
    ajax(`<host3>/data/files/${dataInfo.files}`)
  )
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

And now, streams extend this behavior with powerful operators that break this down even further:

```
// Streams can also compose other streams.
Stream(ajax('<host1>/items')
  .streamMap(item =>
    Stream(ajax(`<host2>/data/${item.getId()}/info`)))
  .streamMap(dataInfo =>
    Stream(ajax(`<host3>/data/files/${dataInfo.files}`)))
  .subscribe(processFiles);
```

Remember that the Stream object here is merely an abstract artifact designed to show you how the paradigm works. In this book, you’ll learn to use the actual objects that implement these abstract concepts to design your applications using a functional and reactive model. But RxJS doesn’t obligate you to use only a single paradigm; it’s often the combination of paradigms that creates the most flexible and maintainable designs.

## Reactive and other programming paradigms

Every new paradigm that you’ll encounter during your programming career will require you to modify your thinking to accommodate the primitives of the language. For example, object-oriented programming (OOP) puts state within objects, which are the central units of abstraction, and the intricacy of the paradigm comes from the interactions that arise when they interact with one another. In a similar fashion, FP places behavior at the center of all things, with functions as the main unit of work. Reactive programming, on the other hand, requires you to see data as a constantly flowing stream of change as opposed to monolithic data types or collections holding all of an application’s state.

Now you’re probably wondering, am I allowed to choose only one? Or can I combine them into the same code base? The beauty behind all this is that you can use all of them together. Many prominent figures in our industry have attested to this. In other words, RxJS doesn’t force on you a certain style of development or design pattern to use - it is unopinionated. Thankfully, it also works orthogonally to most libraries. As you’ll see later on, it’s a simple matter in most cases to adapt an existing event stream such as a DOM event handler into an observable. The library provides many operators for such operations baked directly into it. It will even support unusual design patterns such as those you’ll see when you use a library like React or Redux (which you’ll see in the last chapter).

In practice, you can use OOP to model your domain and use a powerful combination of reactive and FP (a combination known as functional reactive programming) to drive your behavior and events. When it comes to managing events, you’ll soon begin to see an important theme in code involving Rx. Unlike in OOP where state or data is held in variables or collections, state in RP is transient, which means that data never remains stored but actually flows through the streams that are being subscribed to, which makes event handling easy to reason about and test.

Another noticeable difference is the style used in both paradigms. On one hand, OOP is typically written imperatively. In other words, you instantiate objects that keep track of state while running through a sequence of statements revealing how those objects interact and transform to arrive at your desired solution.

On the other hand, RxJS code encourages you to write declaratively, which means your code expresses the what and not the how of what you’re trying to accomplish. RxJS follows a simple and declarative design inspired by FP. No longer will you be required to create variables to track the progress of your callbacks or worry about inadvertently corrupting some closed-over outer state causing side effects to occur. Besides, with RxJS it becomes easy to manage multiple streams of data, filtering and transforming them at will. By creating operations that can be chained together, you can also fluently create pipelines of logic that sound very much like spoken sentences like this: “When I receive a magazine for the month of July, notify me.”

In this chapter, you learned how RxJS elegantly combines both functional and reactive paradigms into a simple computing model that places observables (streams) at the forefront. Observables are pure and free of side effects, with a powerful arsenal of operators and transformations that allow you to elegantly compose your business logic with asynchronous operations. We chose to keep the code abstract for now as we work through some of the new concepts. But we’ll quickly ramp up to a comprehensive theoretical and practical understanding of the library, so that you can begin to apply it immediately at work or on your personal projects. Now it’s time to start really thinking in streams, and that’s the topic of the next chapter.

## Summary

* Asynchronous code can be very difficult to implement because existing programming patterns don’t scale to complex behavior.

* Callbacks and Promises can be used to deal with asynchronous code, but they have many limitations when targeted against large streams generated from repeated button clicks or mouse movements.

* RxJS is a reactive solution that can more concisely and declaratively deal with large amounts of data separated over time.

* RxJS is a paradigm shift that requires seeing and understanding data in streams with propagation of change.

* Streams originate from a producer (observable), where data flows through a pipeline, arriving at a consumer (observer). This same programming model is used whether or not data is separated by time.
